<dom-module id="animated-svg-path">
    <template>
        <style type="text/css">

            path {
                stroke-dasharray: 0%,100%;
                transition: stroke-dasharray [[_animationSpeed]]ms linear;

                stroke: black;
            }

            path.animate {
                display: inherit;
                stroke-dasharray: 100%,0%;

            }

            path.completed {
                display: inherit;
                stroke-dasharray: 100%,0%;

            }
        </style>
    </template>
</dom-module>
<script type="text/javascript">
    // animated-svg-path element
    // An element that houses any collection of paths as children and animates drawing them
    // The order the paths are drawn is is determined by the "order" attribute

    /*
    Example:
    <animated-svg-path>
        <svg>
            <path order="0" ... />
            <path order="1" ... />
        </svg>
    </animated-svg-path>
    */

    (function() {
        // Mapping a nodelist isn't available so we create our
        // own version
        // TODO: This isn't great... this shouldn't have to modify
        // global prototypes
        NodeList.prototype.map = Array.prototype.map
        class AnimatedSVGPath extends Polymer.Element {
            static get is() { return 'animated-svg-path' }

            static get properties() {
                return {
                    // Whether or not to animage the
                    // SVG drawing immediately or not 
                    autoPlay: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true
                    },

                    // How long to take to draw each path
                    // If constant-draw-time isn't enabled
                    // then this is the time it takes to draw
                    // the longest path
                    durationPerPath: {
                        type: Number,
                        value: 1000
                    },

                    // If enabled then each paths takes a the same
                    // amount of time to draw. So short paths will
                    // take a long time to drwa while long paths
                    // will draw fast
                    constantDrawTime: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true
                    },

                    // The current index of paths to draw
                    _currentOrderIndex: {
                        type: Number,
                        value: 0
                    },

                    // The current speed to animate at
                    // Bound in the above style tag
                    _animationSpeed: {
                        type: Number,
                        value: 0
                    },

                    // Key used to check if an async animation loop
                    // has been invalidated
                    _playKey: {
                        type: Number,
                        value: 0
                    }
                }
            }

            /* Overrides */
            _attachDom(dom) {
                this.appendChild(dom)
            }

            /* Lifecycle Functions */
            connectedCallback() {
                super.connectedCallback()
                this.reset()
            }

            /* Public API */
            play() {
                this._clear()

                // find the logest path for the case of
                // non-constant animations
                this._animationSpeed = this.durationPerPath
                const maxPathLength = this.querySelectorAll('path')
                    .map(p => p.getTotalLength())
                    .reduce((val, next) => next > val ? next : val)
                
                // If the playkey has changed, then that means this
                // animation is invalidated
                this._playKey++
                const key = this._playKey

                // perform the animation
                const _do = () => {
                    const coi = this._currentOrderIndex
                    const paths = this.querySelectorAll(`path[order="${coi}"]`)

                    if (!paths || !paths.length) return

                    let speed = this.durationPerPath

                    if (!this.constantDrawTime) {
                        const avgLen = paths
                            .map(p => p.getTotalLength())
                            .reduce((val, next, i) => val += next / (i + 1), 0)

                        speed = this.durationPerPath * avgLen / maxPathLength
                    }


                    // TODO: For some reason the animations seem to finish
                    // in half of the allocated time, so lets double the time
                    // here and setTimeout for the expected time
                    // Could have somethign to do with our dash being 100% rather
                    // than 50%? But with 50%,%50 dasharray there's a lingering tail
                    this._animationSpeed = speed * 2

                    paths.forEach(p => p.classList.add('animate'))
                    setTimeout(() => {
                        paths.forEach(p => {
                            if (this._playKey !== key) return

                            p.classList.remove('animate')
                            p.classList.add('completed')
                            this._currentOrderIndex++
                            _do()
                        })
                    }, speed)
                }
                _do()
            }

            reset() {
                this._clear()
                if (this.autoPlay) this.play()
            }

            /* Private Functions */
            // clear the current state
            _clear() {               
                this.querySelectorAll('path').forEach(p => {
                    p.classList.remove('animate')
                    p.classList.remove('completed')
                })
                this._currentOrderIndex = 0
            }
        }

        customElements.define(AnimatedSVGPath.is, AnimatedSVGPath)
    })()
</script>